## 09. setTimeOut의 비밀

<br>

setTimeOut을 이용해서 콜백함수가 큐 태스크에 쏙 들어온다. 그리고 이 콜백은 언젠가 콜 스택으로 가게 되고, 콜 스택에서 이 콜백이 실행이 되면 다시 handleClick()을 호출하기 때문에 setTimeOut을 호출해서 콜백 함수가 다시 큐에 들어오고 계속 이런 식으로 큐에 들어오게 된다.

계속 스스로를 부르기 때문에 무한정으로 계속 출력이 일어난다. 그런데 계속 계속 버튼이 클릭이 되고 브라우저는 이렇게 이벤트를 처리할 수 있다. 분명 콜 스택에 있는 함수가 실행되는 동안 그 외의 것들은 아무 것도 실행할 수 없는데 어떻게 된 일일까?

<br>

![20](https://user-images.githubusercontent.com/75867748/109422271-32833800-7a1e-11eb-85db-2b1b233a460f.png)

자, 보면 웹 APIs를 이용해서 setTimeOut을 호출했다. setTimeOut에 우리가 등록한 이 콜백 함수를 등록해 놓았다. 웹 APIs는 0밀리세컨드가 지난 다음에 즉 <b>이벤트 루프가 한번 다시 돈 다음에</b> 얘를 태스크 큐에 넣게 되고 태스크 큐에 들어온 아이는 콜 스택으로 가게 되고 콜 스택에서 이 아이가 수행이 된다. 그럼 또 setTimeout을 호출하게 되어 다른 콜백을 등록하게 되고 0밀리세컨드가 지나면 다시 태스크 큐에 가지고 오게 되고 이벤트 루프가 빙글빙글 돌다가 얘를 다시 콜 스택으로 가져오게 되고 이렇게 순회를 하면서 처리를 한다. 이렇게 처리하는 도중에 가끔씩은 렌더 쪽으로 가서 렌더링을 처리하게 된다.

이렇게 무한정 반복되고 있음에도 불구하고 이벤트 루프는 가끔 렌더 쪽으로 오기 때문에 다양한 처리를 할 수 있게 된다.
