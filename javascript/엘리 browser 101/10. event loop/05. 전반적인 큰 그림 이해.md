## 05. 전반적인 큰 그림 이해

<br>

브라우저에는 태스크 큐 말고도 다양한 아이들이 있다. 이 중 두 개만 더 살펴보도록 하겠다.

<BR>

![10](https://user-images.githubusercontent.com/75867748/109420457-f21fbc00-7a15-11eb-9948-668b2dfb652c.png)

<BR>

##### 태스크 큐

- <B>우리가 흔하게 등록한 콜백함수</B>들이 여기 큐에 들어옴
- 웹 APIs에서 우리가 등록한 콜백 함수를 특정한 이벤트가 발생했을 때, 즉 지정된 이벤트가 발생했을 때 태스크 큐에 넣는다.

<br>

##### 마이크로 태스크 큐

- <B>프로미스</B>가 다 수행되고 나면 그 다음에 등록한 then 에 등록한 콜백 함수
- <B>mutation observer</B>에 등록된 콜백 함수
- 만약 백엔드에서 데이터를 받아오는 fetch를 이용해서 프로미스를 만들었다면, 프로미스에 then이라고 콜백함수를 등록하면 이 프로미스가 잘 끝나서 resolve가 되면 그때 등록된 콜백이 바로 마이크로 태스크 큐에 들어오게 된다.

<br>

##### render

- <B>'렌더'란 브라우저에서 우리가 변형한 코드가 주기적으로 업데이트 되기 위해서 주기적으로 호출되는 순서</B>
- 주기적으로 브라우저에서 우리가 요소를 움직이거나 애니메이션을 할 때 <B>화면에 주기적으로 업데이트</B> 해야 함
- 브라우저에서 우리가 변형하는 <B>DOM 요소</B>를 변형된 것이 브라우저에 표기되기 위해서는 <B>렌더 트리</B>가 만들어져야 하고, <B>레이아웃</B> 크기와 위치들이 계산이 된 다음에 <B>paint</B>와 <B>composite</B> 과정을 통해 브라우저에 표기 된다.
- RFA : 웹 API 중 RFA가 있는데, 이 API를 통해 콜백을 등록해놓으면 다음 브라우저가 업데이트 되기 전에 내 콜백을 실행해줘라는 API가 있다. 이때 그때 우리가 호출하는 콜백은 RFA의 큐에다가 차곡차곡 쌓인다.

<BR>

그렇다면 브라우저는 이 많은 큐들을 어떤 순서로 처리하는 걸까?

---

### 브라우저의 실행 순서

- 이벤트 루프는 계속 빙글빙글 돌다가 <b>콜 스택에서 수행 중인 함수가 있으면 이 아이가 끝날 때까지 여기에 머물러</b> 있다. 그리고 실행이 끝나고 나면 다시 빙글빙글 도는데 렌더 쪽으로 갈 수도 안 갈 수도 있다.
- 브라우저에서는 업데이트 내용을 60 frm per second로 보여주려고 한다. 그런데 이벤트 루프는 매우 빠른 속도로 돌아서 한 바퀴 도는데 1ms도 걸리지 않는다. 하지만 1ms마다 업데이트를 할 필요가 없기 때문에, 보통 60frm 마다 <b>업데이트를 한번 해주고 그 다음에 다른 일을 하다가 어느 정도 시간이 됐다 싶으면 다시 렌더 트리를 업데이트</b> 하는 방식으로 운영한다.
- 그래서 이벤트 루프가 렌더를 이미 한번 거쳐갔다면 다른 큐로 간다. 그런데 마이크로 태스크 큐에 아이템이 있네? 그러면 여기에 멈춰서서 여기 큐 안에 들어있는 아이템들이 전부 없어질 때까지 기다렸다가 얘네들을 하나씩 콜 스택에 가지고 간다.
- 하지만 <b>마이크로 태스크 큐에 있는 것들이 전부 텅텅 빌 때까지 이벤트 루프는 그곳에 계속 머무른다</b>. 만약 나중에 또 다른 콜백이 들어왔다해도 나중에 들어온 애들까지 전부 완전히 끝날때까지 계속 콜 스택으로 가지고 와서 수행한다.
- 이제 마이크로 테스크 큐가 완전히 텅텅 비면 다사 순회를 재개하면서 태스크 큐로 넘어온다. <b>마이크로 태스크에서는 새로 들어오는 아이들까지 합쳐 전부 완전히 끝날 때까지 기다린 반면, 태스크 큐에서는 아이템 하나만 콜 스택에 보낸 뒤 이 콜백이 끝날 때까지 기다리고 나서 다시 순회를 시작한다. 이제 업데이트를 할 때가 되었으면 렌더 시퀀스에 들어와서</b> RFA에 등록된 콜백들을 하나하나 다 실행한 다음, 렌더 트리로 와서 렌더 트리를 만들고, 그 트리를 이용해서 레이아웃을 계산한 다음 페인트를 통해 브라우저에 업데이트를 한다. 그리고 다시 이벤트 루프는 순회한다. 여기에 태스크 큐에 아이템이 또 있네? 그러면 콜 스택으로 가지고 가서 실행한다. 그리고 순횐하다가 콜백 함수로 인한 변경사항을 다시 렌더를 통해 업데이트 한다.
