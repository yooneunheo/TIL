## SECTION 14 - 03. 스택의 응용 - 후위표기식 (3)

##### p. 41

< 후위표기식으로 변환 - 괄호없는 경우 : 코드 변환 >

- 후기표기식을 빈 문자열로 만든다.
- 연산자가 들어가는 operator(연산자) stack이 필요하다.
- token이 있을 때까지 while문
  - 다음 토큰을 가져온다
  - if, 다음 토큰이 operand(피연산자)라면
    - 바로 출력
  - else if, operator(연산자)라면 스택에 들어간다.
    - 단, 우선순위가 높은 게 먼저 들어가있으면 그걸 꺼낸 다음에 들어간다. 이러한 처리는 process_operator 함수가 처리한다.
  - else, 그 외의 경우라면
    - error 출력.
- infix expression에 있는 모든 토큰들을 처리했을 때, stack에 남아있는 모든 연산자를 순서대로 pop한다.

<br>

##### p. 42

< process_operator 코드 변환 >

\* process_operator : 하나의 연산자가 토큰으로 들어왔을 때 그 연산자를 처리하는 규칙이다. 어떤 연산자든 push되어야 하지만, 이미 들어간 연산자들 중에서 push하려는 것보다 우선순위가 높은 게 있다면 그걸 다 꺼내고 push하는 것이다.

- if, 스택이 비워져있다면
  - 현재 처리하려는 연산자를 push한다
- else, 스택이 비워지지 않았다면
  - peek(스택에서 제거하지 않고 리턴만 함)해서 현재 top에 있는 연산자를 변수 top_op에 넣는다. 그리고 현재 내가 넣을 연산자를 cur_op라고 한다.
  - if, cur_op > top_op 라면
    - top_op는 나올 자격이 없으므로 바로 cur_op를 push한다
  - else, 스택 안에 있는 연산자가 cur_op보다 우선 순위가 높다면
    - 하나만 꺼내는게 아니라 우선순위가 같거나 높은 것들을 다 꺼내야하므로 while문 사용 && 스택이 비워져있지 않음
      - top_op를 꺼낸다
    - 만약, stack이 비워져있지 않을 때
      - 다시 맨 위에 있는 것을 peek해서 top_op로 만든다.
    - 현재 연산자를 전부 스택에 push한다.

<br>

##### p. 43

- \#include <stackADT.h> 해서 그 안에 있는 Stack을 사용할 것이다. 그런데 그 스택은 int 형식인데, 우리가 사용할 operator_stack은 연산자들을 저장하기 때문에 char 형식이어야 한다. 하지만 나중에 후위표기식으로 계산할 때 사용할 operhand_stack은 정수 타입이므로, stack은 char과 int 두 가지 형식이 필요하다.
- 다행히 c는 int와 char의 호환이 지원되므로 각각 다른 stack을 만들지 않아도 된다.

<br>

##### p. 44

![20](https://user-images.githubusercontent.com/75867748/110462754-6fcd8100-8114-11eb-9a2a-e6782a56641e.jpg)

- postfix는 동적할당한 메모리의 시작주소를 저장한다. 현재는 빈 배열이고, 나중에 데이터들을 후위표기식으로 변환하면서 채워넣는다. 그리고 변환시킬 위치를 나타내는 포인터가 pos이다. 따라서 postfix 배열에서 pos의 앞칸까지는 변환된 후위표기식이 자리를 차지하고 있고 뒤부터는 비어있다. 물론 pos는 처음엔 postfix와 같은 주소를 가지고 있겠다.

<br>

![21](https://user-images.githubusercontent.com/75867748/110463282-1154d280-8115-11eb-994c-c85259ce34cb.png)

- token 이 예를 들어 123이라면, postfix 배열은 pos가 가리키는 곳에서 123을 append 해야한다. append할 때 strcat 함수보단 sprintf 함수를 이용하도록 하겠다. 왜냐하면 strcat은 합치려는 두 문자열이 널(\0)로 끝나야지만 사용 가능하기 때문이다. 하지만 지금 infix 식에서는 연산자와 피연산자 사이에 공백이 들어가기 때문이기도 하고, 또 postfix를 만들어가는 과정이라 중간중간마다 널을 넣기 애매하기 때문이다.
- sprintf(pos, "%s ", token) : 문자배열 postfix에서 pos가 가리키고 있는 위치에 token을 쓴다. sprintf이므로 화면에 출력하는 게 아니라 문자열에 써준다. "%s "이므로 토큰 뒤에 공백 한 칸을 출력. 그리고 pos는 token의 길이+한칸 뒤로 더 밀려난다.
- process_op 는 스택에 있는 연산자의 우선순위를 다루기 때문에 후위표기식을 출력할 자리인 pos를 알아야 한다. 그리고 항상 문자열의 끝주소를 반환해야 제대로된 pos 값을 알 수 있다.

<br>

##### p. 46

postfix 배열에서 pos 앞까진 이미 변환된 수식이 차있고, 새로 출력할 것들은 pos에 출력하면 된다.

- if문은 스택이 비어져있을 때 스택에 연산자를 넣은 다음 내가 받아온 pos값을 그대로 리턴한다. 아무것도 출력된 게 없기 때문이다.
- 스택이 empty가 아니라면, 현재의 연산자가 기존 스택에 있는 것들보다 우선순위가 높다면 push하고 끝낸 다음 pos를 그대로 리턴한다.
- 그렇지 않다면 while문을 돌면서 다 꺼내고 push를 한다. 여기서 pop을 할 때 리턴되는 값을 변수로 받을 필요가 없다. 위의 top_op = peek()가 이미 pop되는 연산자를 가리키기 때문이다. 그리고 top_op는 스택에 나왔으므로 출력하면 된다. sprintf로 출력을 하고 pos는 두 칸 밀려나간다. 왜냐하면 연산자 하나와 빈 칸 하나인 "%c "이기 때문이다.
- 만약 stack이 비어져있지 않다면 또 top_op에 최상단 값을 peek하고 while문을 다시 돈다. 현재 연산자보다 우선순위가 높은 것들을 이런 식으로 다 꺼낸 다음에 최종적으로 push(operator_stack, op)해서 현재의 연산자를 집어넣는다.

<br>

##### p. 45

44 페이지의 while문이 종료되면 입력으로 들어온 infix가 후위표기식으로 완전히 처리된 셈이다. 그러나 스택에 여전히 남아있는 연산자들을 순서대로 꺼내서 출력한다.
