## SECTION 18 - 01. 시간복잡도 분석 예 (1)

<br>

##### p. 24

reallocate는 n개의 배열을 다른 배열로 옮기는 작업이기 때문에 시간 복잡도가 O(n)일 수밖에 없다. 하지만 나머지 부분은 O(1)인데, 데이터가 몇 개가 들어있느냐와 관계없이 어쨌든 스택의 제일 위인 top에 데이터를 하나 추가하는 것이기 때문이다. 그런데 일반적으로 배열을 사용하는 알고리즘의 시간복잡도를 말할 때 reallocate 의 시간은 빼고 말하는 것이 일반적이다. 따라서 이 경우는 시간복잡도가 O(1)이라고 볼 수 있다.

<br>

##### p. 25

연결 리스트도 마찬가지로 O(1)인데, 맨 앞에 노드를 하나 추가하거나 삭제하는 건 연결리스트의 길이와 무관하기 때문이다.

<br>

##### p. 27

순서대로 정렬된 리스트에 어떤 값을 삽입하고자 한다. 위치를 찾았을 때, 자리를 한칸씩 옮겨야 하므로 데이터의 갯수에 비례하여 처리 속도가 늘어날 것이다. 최악의 경우는 들어갈 데이터가 배열의 제일 앞에 삽입될 때인데, 모든 데이터들이 뒤로 한칸씩 물러가야 하기 때문이다. 따라서 최악의 경우 시간복잡도는 O(N)이다.

이를 보완할 방법은 총 세 가지이다.

이진검색을 하면 위치를 찾는 시간이 절반씩 줄어드므로 O(logN)이 된다. 그런데 어차피 큰 데이터들은 뒤로 한칸씩 물러나야 되므로 결국은 O(N)이 되서 이진검색을 쓰는 이유가 퇴색된다.

맨앞에서부터 비교해서 처음으로 나보다 큰 값이 나오면 멈추는 방법도 있다. 하지만 이것도 그리 좋은 아이디어는 아니다. 나보다 작은 값들을 계속 살펴야하고, 또 위치를 찾았다해도 뒤에 있는 큰 값들이 자리를 한칸씩 비켜줘야하기 때문이다.

가장 좋은 방법은 (이진검색을 제외하고) 뒤에서부터 검사하는 것이다. 끝에서부터 비교하는데, 내가 추가하려는 데이터보다 현재 비교하는 데이터가 크면 뒤로 보내고, 또 추가하려는 데이터보다 크면 뒤로 한칸 보내고.. 나보다 작은 값이 나오거나 인덱스가 -1이 되기 전까지 반복한 뒤 삽입한다. 앞에서부터 검사하는 것보다 더 효율적이다. 그리고 지금 27페이지의 코드가 바로 이 경우일 때이다. 물론 최악의 경우는 시간복잡도가 O(N)이 될 것이다.(추가하려는 데이터가 가장 작은 값이라 맨 앞에 삽입될 때)

<br>

##### p. 28

단방향 연결리스트는 뒤에서부터 검사를 할 수가 없고 이진검색도 사용할 수 없다(중간 노드를 구할 수 없으므로). 첫번째 노드부터 시작해서 나보다 큰 데이터가 나오거나 연결 리스트의 끝에 도달할 때까지 살펴본다. 단방향 연결리스트에서는 어떤 노드 앞에 새로운 노드를 만들어 넣을 수 없으므로 두 개의 포인터 p와 q를 이용해서 q는 항상 p를 따라다니게 하여 나보다 큰 값이 발견되면 add_after(q)를 한다.

q가 널인 경우는 내가 들어가 위치가 연결 리스트의 맨 앞일 때를 의미한다. 그럴 땐 add_first를 하면 된다. 그렇지 않을 때는 add_after(q) 를 해서 q 뒤에 새로운 노드를 만들어준다.

최악의 경우는 새로 들어가는 값인 내가 최댓값이어서 모든 노드를 다 스캔해서 맨 뒤에 들어갈 때이므로 O(N)이다.

연결 리스트에서 가장 중요한 것은 첫번째 노드의 주소를 잃어버리지 않고 보관하는 것이다. 따라서 head 변수가 첫 번째 노드 주소를 가리키도록 만드는데, 이 때 상황이 두 가지가 있다. 하나는 head가 전역변수일 때이다. 전역변수라서 어느 곳이든 노드의 첫 번째 주소에 접근 가능하기 때문이다. 그런데 가끔 이 연결리스트가 일부 함수에서만 사용될 경우, 지역변수로 저장해야 된다. c언어는 매개변수가 값에 의한 호출이므로, 나를 호출한 함수 안의 head 변수와 매개변수 head가 별개의 변수가 된다. 다만 매개변수를 호출할 때 지역변수 head의 값이 호출한 함수 내 변수에 복사되어 head가 연결 리스트의 첫번째 노드를 가리키긴 하지만, 두 head는 다른 변수인 것이다. 다시 말해, 원래 첫번째 노드를 가리키던 지역변수 head와 다른 함수를 호출할 때 사용할 매개변수 head는 전혀 다른 변수이다. 그리고 호출된 함수에선 매개변수 head 의 값을 이용해서 연결 리스트의 첫번째 주소를 찾아가 처리를 한다. 그런데 이 호출한 함수에서 첫 번째 노드를 변경할 가능성이 있다면 주의를 해야한다.

예를 들어 호출한 함수의 역할이 연결 리스트에 새로운 노드를 만들어 데이터를 저장하는 건데, 하필 맨 앞에 들어가야 할 경우. 새로운 노드의 next가 원래 head가 가리킨 첫번째 노드를 가리키고 head가 새로운 노드를 가리키게 한 다음 그냥 리턴해버린다면... 원래 이 함수를 호출했던 함수가 가지고 있는 변수 head의 값은 여전히 변경되기 전 원래 첫 번째 노드를 가리킨다. 즉 다시 원래 상태이게 된다. 따라서 변경할 가능성이 있는 경우라면, 1. head의 값이 아닌 head의 주소, 즉 더블 포인터를 넘기거나, 2. 변경된 head 노드 값을 반환해야 한다.
