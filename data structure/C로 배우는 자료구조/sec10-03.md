## SECTION 10 - 03. 연결 리스트 - 다항식 (3)

<Br>

##### p. 54

##### 함수를 새로 정의한 경우(f = ...)

다항식의 수식을 입력받아서 f는 name, 실제 수식은 body에 해당한다. body 부분을 해석하여 하나의 다항식 객체를 만들어 다항식 객체의 주소를 리턴함.

- begin_term은 항 단위로 현재 내가 보고 있는 항을 가리킨다.

- 첫번째 항을 제외한 나머지 항들은 +나 -로 시작한다.

![16](https://user-images.githubusercontent.com/75867748/109977055-c2d3bc80-7d3f-11eb-891e-5f1eeb77d7ba.png)

- begin_term에서 시작하여 쭉 스캔하다가 +나 -가 나오기 직전까지가 하나의 항이다. begin보다는 크거나 같고 i보다는 작다. 폐구간-개구간으로 body[begin_term, i) 까지가 하나의 항이다. 다시 말해, 문자열 body에서 begin_term번째부터 i-1번째까지가 하나의 항이다.

- parse_and_add_term 함수는, 문자열 body에서 begin_term번째부터 i-1번째까지가 하나의 항일때, 그 안에서 계수와 차수를 찾아 내어 하나의 항을 만든다. 그리고 그 항을 ptr_poly가 가리키는 다항식에 add한다. 실패하면 0, 성공하면 1을 리턴한다. 그런데 실패했을 때 0만 리턴하면 이전에 만든 수식인 ptr_poly는 쓸모없어진다. 따라서 destroy_polynomial(ptr_poly)를 해서 garbage로 만들어 free 시킨다.

- 어쨌든 완료되면 다음 항으로 넘어가서 이전과 같은 단계를 또 거친다. 그래서 parse_and_add_term에 다음 항을 add 한다. 그리고 문자열의 끝까지 도달했다면 최종적으로 생성한 다항식을 리턴시킨다.

<Br>

---

<Br>

##### p. 56

다양한 경우를 고려해야 한다.
12x^11 : 계수가 있고 양수일 때
-5x^3 : 계수가 있고 음수일 때
x^2 : 계수가 없고 양수일 때
-x^3 : 계수가 없고 음수일 때

<Br>

---

<Br>

##### p. 57

expr[i]는 digit 즉 계수를 가리킨다. 예를 들어 123일 경우, 우선 0\*10 + 1이다. 그리고 2를 읽게 되면 1\*10+2 = 12가 된다. 그리고 3을 읽을 땐, 12에 10을 곱한 다음 3을 더하면 된다. 그리고 expr[i]는 숫자가 아닌 아스키 코드이기 때문에 바로 연산을 할 수 없고 아스키 코드 0을 빼면 숫자가 된다. (ex) '5' - '0' = 5 (정수)

- while 문은 계수의 절대값을 구하는 케이스이다.
- if (coef == 0) 은 계수가 0 이 아니라 1이다. (ex) x^4 라면 while문이 실행되지 않는다. digit가 아니므로 while문을 건너뛰게 되서 coef가 0으로 되어있다.

- if(i>=end) 는 항이 끝났을 때를 의미하므로 계수 부분만 있는 항을 의미한다. 따라서 지금까지 구한 계수 coef에 차수는 0인 항을 p_poly에 add한다. 성공하면 1을 리턴.

<Br>

---

<Br>

##### p. 58

- 만약 상수항이 아니라면 x가 있어야하므로 if(expr[i] != 'x') 일 땐 오류를 리턴한다.

- 그런데 일차항에서 수식이 끝날 수 있다. 일차항은 차수가 1인 항이다. (ex)5x

- 일차항에서 끝났는데 ^가 등장했다면 이건 오류

<Br>

---

<Br>

##### p. 59

![20](https://user-images.githubusercontent.com/75867748/109984819-7e4c1f00-7d47-11eb-950e-fd821d063ba4.png)

insert_polynomial은 다항식들을 거느리는 polys에 새로운 다항식을 insert 해주는 함수이다.

그런데 이름이 똑같은 다항식이 이미 존재할 수 있다. 그럴 땐 기존의 다항식이 삭제되고 새로운 게 그 자리에 들어오게 된다.
