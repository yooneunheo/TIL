## SECTION 18 - 02. 시간복잡도 분석 예 (2)

<br>

##### p. 29

배열 c에 배열 a를 복사하는 건 m번 걸린다. 따라서 O(m)이다.

배열 c는 정렬된 상태를 유지한다. m 크기의 배열에 값 하나를 insert하면 걸리는 시간은 총 m이 될 것이다. 그리고 여기에 값을 하나 더 insert하려면 데이터가 이미 하나 늘었기 때문에 m+1 의 시간이 걸릴 것이다. 이런 식으로 결국 m+(n-1)번의 비교까지 가게 될 것이다. 따라서 m + mn + n(n-1)/2 인데 mn이 n(n-1)/2가 더 크므로 O(mn)이 된다. 이 경우는 그다지 효율적인 방법이 아니다.

<br>

##### p. 30

배열 c에서 첫 번째 데이터로 들어올 수 있는 건 두 배열 a와 b 통틀어 가장 작은 값일 것이다. 그런데 배열 a와 b는 이미 각각이 정렬되어 있으므로, 배열 a에서 가장 작은 값과 배열 b에서 가장 작은 값을 한번만 비교하면 될 것이다. 그래서 a나 b 한 쪽 배열이 완전히 끝날 때까지 while문을 돌린다. 그리고 남아있는 것들은 이미 그 자체로 정렬이 되어 있기 때문에 배열 c에 옮겨오지 못한 것들을 또 while문을 사용해서 마저 옮겨온다.

<br>

##### p. 31

두 연결리스트를 합칠 때, 하나의 연결 리스트는 그냥 두고 다른 연결 리스트를 거기에 하나씩 insert하는 경우를 살펴보자. p.28과 같은 방식이다. 두 개의 포인터 p와 q를 이용해서 삽입하는 방식으로 O(n)이 걸린다. 
