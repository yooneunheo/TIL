## SECTION 18 - 02. 시간복잡도 분석 예 (2)

<br>

##### p. 29

배열 c에 배열 a를 복사하는 건 m번 걸린다. 따라서 O(m)이다.

배열 c는 정렬된 상태를 유지한다. m 크기의 배열에 값 하나를 insert하면 걸리는 시간은 총 m이 될 것이다. 그리고 여기에 값을 하나 더 insert하려면 데이터가 이미 하나 늘었기 때문에 m+1 의 시간이 걸릴 것이다. 이런 식으로 결국 m+(n-1)번의 비교까지 가게 될 것이다. 따라서 m + mn + n(n-1)/2 인데 mn이 n(n-1)/2가 더 크므로 O(mn)이 된다. 이 경우는 그다지 효율적인 방법이 아니다.

<br>

##### p. 30

배열 c에서 첫 번째 데이터로 들어올 수 있는 건 두 배열 a와 b 통틀어 가장 작은 값일 것이다. 그런데 배열 a와 b는 이미 각각이 정렬되어 있으므로, 배열 a에서 가장 작은 값과 배열 b에서 가장 작은 값을 한번만 비교하면 될 것이다. 그래서 a나 b 한 쪽 배열이 완전히 끝날 때까지 while문을 돌린다. 그리고 남아있는 것들은 이미 그 자체로 정렬이 되어 있기 때문에 배열 c에 옮겨오지 못한 것들을 또 while문을 사용해서 마저 옮겨온다.

<br>

##### p. 31

![40](https://user-images.githubusercontent.com/75867748/110943878-10bf7480-837f-11eb-9e27-31330c07c194.png)

first 배열에다가 second 배열을 하나씩 끼워 넣을 때 m > n이면 O(mn) 이고, n > m 이면 O(n^2)이다. 따라서 긴 배열에다가 짧은 배열을 하나씩 끼워 넣는 게 시간복잡도 면에서 더 낫다.

<br>

##### p. 32 ~ 33

first 배열과 second 배열 중 가장 작은 값을 비교하여 tmp 변수에 대입한 다음, 새로운 배열의 맨 꽁무니(tail)에 넣는다. 마지막 칸(tail)에 들어가니까 tmp->next는 NULL이 되어야 한다. 만약 tail이 널이라면 현재 배열이 비어있다는 소리이므로 head = tail = tmp이다. 이런 식으로 first나 second 둘 중 하나가 빌 때까지 tail에 계속 추가한다. 그리고 남은 부분은 어차피 이미 정렬되어 있으므로 그대로 tail에 추가하면 된다.

<br>

##### p. 34

p. 31 에서처럼 기존 노드에 하나씩 insert하는 방식이다. 근데 p. 31에서 O(mn)인 이유는, 노드를 하나 삽입하고 나서 다음 노드를 또 삽입할 때 삽입이 될 연결 리스트를 처음부터 검토한 다음 삽입하기 때문이다. 그런데 연결 리스트는 이미 순서대로 정렬되어 있기 때문에 굳이 처음부터 검토하지 말고 이전의 노드가 삽입된 곳 이후부터 검토하면 시간이 훨씬 줄어들 것이다.

일반적으로 두 개의 반복문이 중첩되어 있으면 O(n^2) 이거나 O(mn) 이기 쉽지만 반드시 그렇진 않다. p. 34의 경우 두 개의 while문이 중첩되어 있지만 p, q, the node 가 전진만 하지 후진하진 않기 때문에 문장의 총 실행횟수가 m+n을 넘지 않는다.

<br>

##### p. 35

![41](https://user-images.githubusercontent.com/75867748/110947605-b83ea600-8383-11eb-9c9e-0b3aaeb0296b.png)

<br>

##### p. 36

특정 조건을 만족해서 그 노드(p)를 지우려고 하면, 그 앞에 있는 노드(q)가 필요하다. 노드를 지우고 나서 또 다시 처음부터 돌아가서 새로 검토하지 않고 지운 그 자리 이후부터 검토해서 지운다.

![42](https://user-images.githubusercontent.com/75867748/110948459-b5908080-8384-11eb-9b76-d15275fcbfb0.png)

<br>

##### p. 37

한번 왔던 곳은 다시 가지 않는다. 따라서 미로가 n\*n 이므로 O(n^2)을 넘지 않는다.
