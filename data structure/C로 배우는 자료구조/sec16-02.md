## SECTION 16 - 02. 큐의 개념과 구현 (2)

<br>

큐를 배열로 구현하는 법을 먼저 살펴보자

<br>

##### p. 14

배열의 경우 환형(circular) 으로 만들어야 한다. 예시에서 12, 5, 7을 삭제해서 세 칸이 남아도 rear은 9가 차지하고 있기 때문에 배열을 뒤에서 새로 추가하지 못한다. 따라서 남아있는 칸을 front로, 빈 칸은 rear로 만들어 새로 추가한다.

<br>

##### p. 15

Item \*contents : contents를 배열이 아닌 포인터로 선언했다는 건 동적으로 구현했다는 말

<br>

##### p. 16

![12](https://user-images.githubusercontent.com/75867748/110622417-c56e6000-81de-11eb-9d36-367458535b60.png)

<br>

##### p. 17

make_empty는 큐를 비우는 용도이다. free를 할 필요 없고 q->contents는 그냥 두면 된다.

<br>

##### p. 18

1. enqueue

- 뒤에 데이터를 추가하려면 rear을 하나 증가 시킨 다음에 거기에 데이터를 넣는다. 즉,

  - r++;
  - contents[r] = item;

- 현재 큐가 꽉 찼다면 배열의 크기를 키운 다음에 재할당해준다.

- 그런데 만약 rear가 배열의 마지막칸에 있는데 하나 증가시킨다면 rear가 다시 제일 앞으로 돌아가야한다. 그걸 한 줄의 코드로 하면 rear을 1 증가 시킨 다음 capacity로 나누어서 나머지로 구하면 된다.
  q->rear = (q->rear+1) % (q->capacity)
  이렇게 circular 연산일 때는 나머지를 이용해서 구한다.

<br>

2. dequeue

- 맨 앞에 있는 걸 삭제하면 front는 그의 다음 칸을 가리켜야 하므로 한칸 뒤로 밀려난다. 그런데 만약 front가 배열의 끝에서 다음 칸으로 옮겨간다면 다시 앞으로 가야 한다. 따라서 여기서도 그냥 1을 더하는게 아니라, 나머지를 이용해서 circular 연산을 구한다
