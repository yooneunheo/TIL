## SECTION 17 - 03. 시간복잡도와 점근적 분석 (3)

<br>

##### p. 20

![31](https://user-images.githubusercontent.com/75867748/110835158-c9cf7180-82e1-11eb-9ad5-050896c45382.png)

버블소트 알고리즘은 전체 중에서 가장 큰 값을 맨 마지막 자리로 갖다놓은 후 잊어버리고, 또 남은 배열 중에서 가장 큰 값을 맨 마지막에 갖다놓은 후 잊어버리는 방식

따라서 0 ~ i 중에 최대값을 data[i]에 넣는다.

그렇다면 시간 복잡도는?

i = n-1 일 땐, j는 0 ~ i-1 까지 도니까 n-1번 돌고
i = n-2 일 땐, j는 0 ~ i-2 까지 도니까 n-2번 돌고
i = n-3 일 땐, j는 0 ~ i-3 까지 도니까 n-3번 돌고
.
.
.
i = 2 일 땐, j는 0 ~ 1 까지 도니까 2번 돌고
i = 1 일 땐, j는 0 만 도니까 1번 돌고

따라서 1+2+3+4..+(n-1) = n(n-1)/2 , 즉 O(n^2)이다.

그리고 최악의 경우나 최선의 경우나 평균 시간 모두 O(n^2) 걸린다. if(data[j] > data[j+1]) 을 비교하는 연산은 데이터의 갯수가 동일하다면 항상 동일한 갯수만큼 실행되기 때문이다.

<br>

##### p. 21

![32](https://user-images.githubusercontent.com/75867748/110838342-b2928300-82e5-11eb-9961-abb929951494.png)

삽입정렬은 새로운 데이터를 기존의 배열에 넣을 때 순서에 맞게 삽입할 때 사용한다. 삽입 연산을 반복적으로 수행함으로써 데이터를 정렬한다.

일단 8만 있는 배열이 있다. 여기에 4를 정렬에 맞게 제자리에 삽입해서 순서대로 정렬된 배열 4 8을 만든다. 그리고 여기에 또 1을 제자리에 맞게 삽입하여 1 4 8 이란 배열을 만든다. 이런 식으로 반복문을 돌려 마지막칸이 n-1이 될 때까지 수행한다.

이제 코드를 살펴보자
우선 내가 삽입할 데이터는 data[i]이고 tmp에 대입한다.
그리고 j는 i-1, 즉 현재 만들어진 배열의 제일 마지막 칸을 가리킨다.
j는 0보다 크거나 같고, data[j] > tmp 라면 data[j]는 뒤로 한 칸 물러간다.

예시를 들자면 배열 4 8 에 1을 넣으려 한다. data[j]인 8은 tmp인 1보다 크다. 따라서 8은 한 칸 뒤로 간다. 그리고 j--를 하면 data[j] = 4 와 tmp인 1을 비교한다. 역시나 4가 더 크기 때문에 한 칸 뒤로 간다. j가 이제 0보다 작기 때문에 while문을 빠져 나오면서 data[j+1] 자리에 tmp 가 들어간다.

이 경우 최선의 경우와 최악의 경우, 평균이 다르게 나타난다.

최선의 경우는 매번 삽입하려는 데이터(data[i])가 내 앞에 있는 데이터(data[i-1])보다 크기 때문에 while문이 한번만 실행되고 빠져나오게 되므로 O(N)이 된다.

최악의 경우는 데이터가 거꾸로 입력되었을 때이다. 5 4 3 2 1 일 때, 4는 5와 비교해야 하고, 또 3은 4 5 와 비교해야하는 등... n(n-1)/2 이 되므로 O(N^2)이 된다.

하지만 평균적으로는 절반 정도의 시간이 걸린다. 따라서 일반적으로는 버블 소트보단 삽입정렬이 더 낫다. 버블은 항상 n(n-1)/2 이지만, 삽입정렬은 최악의 경우가 n(n-1)/2 이기 때문이다.

<br>

##### p. 22

실제로 프로그래머는 대부분 퀵소트를 사용한다. 배우는 단계라면 모를까 버블 소트를 사용하는 건 그다지 좋지 않은 경우이다.

지금까지 배운 알고리즘들은 배열을 전제로 했다. 만약 연결 리스트에 저장된다면, 어떤 방법을 사용하든 O(N^2)의 복잡도를 벗어나기 힘드며 일종의 삽입정렬과 비슷한 방법을 쓰게 된다. 데이터를 하나씩 삽입하는 방식이기 때문이다.
