## SECTION 9 - 01. 연결리스트 - 개념과 기본 동작들 (1)

<Br>

##### p. 3

1. List(리스트)와 Set(집합)

- 공통점 : 여러개의 데이터를 가지고 있음
- 집합은 원소들 간의 순서 개념이 없지만, 리스트는 있다.

<Br>

---

<Br>

## SECTION 9 - 03. 연결리스트 - 개념과 기본 동작들 (3)

<Br>

##### p. 13

일반적인 경우 뿐 아니라 특수한 경우, 지금 상황에선 연결 리스트가 0일 경우에도 저 코드가 유효한가?

![01](https://user-images.githubusercontent.com/75867748/109766329-5ec6d080-7c39-11eb-8802-278616e93796.png)

tmp -> next = head;

일 때, 원래 리스트가 0이었으므로 head는 null을 가리킨다.
따라서 tmp -> next = NULL; 이 되고 새로 만든 이 노드는 처음이자 마지막 노드가 되고 head가 새로 가리키게 되면서 우리가 원하는 바가 된다. 따라서 이 경우에도 문제가 없는 코드임을 알 수 있다.

<Br>

##### p. 14

첫번째 노드를 가리키는 포인터 head가 전역변수가 아니라 어떤 함수의 지역변수일 경우, 맨 앞에 노드를 새로 추가하고 싶어 add_first함수를 호출한다면 head의 정보를 어떻게 add_first에게 넘길까?

<br>

연결 리스트의 첫번째 노드의 주소, 즉 head 자체를 매개 변수로 가져오면 될까? (값에 의한 호출)

![02](https://user-images.githubusercontent.com/75867748/109767850-8028bc00-7c3b-11eb-903f-90ea9906cce2.png)

하지만 이 경우 마지막 코드에서 문제가 생긴다. head의 값이 새로운 노드로 바뀌어야 한다. 하지만 add_first를 호출했던 곳에서의 head의 값에는 영향을 끼치지 못한다. 왜냐하면 add_first의 블럭 내에서의 head만 바뀌기 때문이다. (add_first의 매개변수로 넘긴 head는 원래 함수의 head와 별개의 변수이다.) 결국 add_first가 종료되고 원래 함수로 돌아가면 head는 원래 기존에 가지고 있던 값을 가지게 된다.

<Br>

##### p. 15

지역변수의 값에 영향을 끼치고 싶으면, 변수의 값 대신 주소를 매개변수로 넘기면 된다. 따라서 head 노드의 주소인 head의 값을 넘기는게 아니라 그의 주소를 매개변수로 넘긴다.

<br>

![04](https://user-images.githubusercontent.com/75867748/109770977-9f294d00-7c3f-11eb-8bf7-c25156207816.png)

ptr_head 연결 리스트의 첫번째 주소(head)의 주소를 가지고 있게 된다. 따라서 세번째줄 코드의 \*ptr_head에는 head의 값, 첫번째 노드의 주소가 들어가있다. 그리고 temp는 새로 만들어진 노드의 주소를 담고 있으므로 temp 그대로 \*ptr_head에 대입한다.

---

<Br>

## SECTION 9 - 04. 연결리스트 - 개념과 기본 동작들 (4)

<Br>

##### p. 19

insert_after()에 비해 insert_before()은 좀 더 복잡하다. 왜냐하면 내 다음 노드의 정보는 알 수 있지만, 내 노드 이전의 정보는 알 수 없기 때문이다.

<Br>

##### p. 21

head가 NULL이면 연결 리스트가 없다는 말이므로 NULL 리턴
그리고 else의 경우, 리턴된 값인 tmp에는 삭제된 원래의 head값이 들어가게 된다. 리턴값을 free해주면 가비지 콜렉터에 의해서 사라지게 된다.

---

<Br>

## SECTION 9 - 05. 연결리스트 - 개념과 기본 동작들 (5)

<Br>

##### p. 29

if(q==NULL) 인 경우는 첫번째 노드를 삭제할 경우이다. p는 첫번째 노드이고 q는 null이므로.
