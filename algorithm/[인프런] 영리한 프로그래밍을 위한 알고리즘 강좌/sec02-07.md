## 2- 07. 멱집합

<br>

![10](https://user-images.githubusercontent.com/75867748/111077069-77d15a80-8532-11eb-852a-c689d610ec73.png)

멱집합이란 어떤 집합의 모든 부분집합의 집합을 말한다.
n개의 원소가 있는 집합의 모든 부분집합의 갯수는 2^n개이다.

---

##### 첫 번째 방법

![14](https://user-images.githubusercontent.com/75867748/111078139-82dab980-8537-11eb-9e29-6e185bb457d9.png)

<br>

![13](https://user-images.githubusercontent.com/75867748/111077828-ef54b900-8535-11eb-9298-c38fba130ae7.png)

- 공집합이라면
  - 아무것도 출력 안함
- 아니라면
  - 매개변수인 집합 s의 한 요소 t에 대해, t를 제외한 부분집합을 구한다
  - 그리고 부분집합들을 그대로 출력
  - 거기에 t를 추가한 다음에 출력

<br>

이 코드에는 문제점이 있다.

recursion에 부여할 미션을 단순히 모든 부분집합을 출력하는 것으로 하면, recursion에서 추가로 해결해야하는 과제인 "부분집합을 구한 후 거기에 또 다른 집합을 추가해서 출력하는 것" 을 해결하기가 어려워진다.

상세한 이유는 다음과 같다.

외부에서 호출한 powerset은 멱집합들을 출력해야 하지만, recursion인 powerset(s-t)은 자기가 구한 멱집합을 출력이 아닌 리턴을 해야 한다. 만약 출력하고 끝내면 자기가 구한 멱집합을 t와 포함해서 또 출력하는 게 불가능하기 때문이다. 그렇다고 외부에서 호출한 powerset이 리턴만 하면, 출력을 해야된다는 목적이 사라진다. 그렇다고 바로 출력만 하면 되는 걸 굳이 데이터들을 어딘가에 저장한 다음 출력해서 메모리를 낭비시키는 일은 바람직하지 않다.

어떻게 해결해야 할까?

---

##### 두 번째 방법

어쨌든 recursion을 설계할 땐, "부분집합을 구한 후 거기에 또 다른 집합을 추가해서 출력"하도록 만들어야 한다.

<br>

![15](https://user-images.githubusercontent.com/75867748/111078359-53787c80-8538-11eb-9748-f9688cd72a39.png)

<br>

![16](https://user-images.githubusercontent.com/75867748/111078408-90447380-8538-11eb-85be-10161a8d0e18.png)

입력으로 두 개의 집합을 필요로 한다.
S의 멱집합을 구한 다음 각각에 P를 합집합해서 출력한다.

물론 맨 처음 호출할 땐 P가 공집합이고, S는 집합 전체를 준다.

<BR>

- S가 공집합이면 P를 그대로 출력
- S가 공집합이 아니라면
  - (P)와 (첫번째 원소를 제외한 S)의 합집합 출력
  - (P와 첫번째 원소의 합집합)과 (첫번째 원소를 제외한 S)의 합집합 출력

<BR>

이 코드를 자세히 보면 결국 이 말이다.

![18](https://user-images.githubusercontent.com/75867748/111078679-0e554a00-853a-11eb-8ec8-84a67ea4eb6c.png)

<BR>

![19](https://user-images.githubusercontent.com/75867748/111078766-7d32a300-853a-11eb-860c-cc68ea0f9169.png)

![20](https://user-images.githubusercontent.com/75867748/111078973-4ad57580-853b-11eb-8d15-d1c346693b9f.png)

<BR>

즉 powerSet 함수는 집합 S(k번째 원소 ~ n-1번째 원소)의 부분집합을 구해서, 집합 P(0번째 원소 ~ k-1번째 원소)에서 include가 true인 원소들을 포함시켜서 출력한다.

k번째 원소부터 집합 S에 속한다. 따라서 k==n이란 말은 S가 공집합이라는 의미이므로 P만 출력하면 되므로 P에서 include가 true인 애들만 출력한다.

<br>

```
include[k] = false;
powerSet(k+1);
```

의 경우는 집합 S에서 첫번째 원소인 K를 포함하지 않는 부분집합을 출력하는 경우를 말한다.
powerSet(k+1)은 k+1번부터 n-1번까지 원소들이 다시 집합 S가 되어(파란칸 표시) 그것의 부분집합을 구한 후, P에서 true인 애들과 함께 출력한다.

```
include[k] = true;
powerSet(k+1);
```

는 집합 S에서 첫 번째 원소 K를 포함하는 부분집합을 출력하는 경우를 말한다. powerSet(k+1)은 k+1번부터 n-1번까지 원소들이 다시 집합 S가 되어(파란칸 표시) 그것의 부분집합을 구한 후, K번째 원소와 함께 P에서 true인 애들 모두 출력한다.

---

일반적으로 이런 구조의 recursion을 설계할 때, 또 다른 방식으로 상태(탐색)공간트리가 있다.

(그림에 오류가 있음. include와 exclude가 바뀜)

![22](https://user-images.githubusercontent.com/75867748/111079069-b4558400-853b-11eb-9d56-fb6f10fd6851.png)
