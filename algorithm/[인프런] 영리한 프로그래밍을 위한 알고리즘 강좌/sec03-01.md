## 3 - 01. 기본적인 정렬 알고리즘

<br>

#### 선택정렬

![01](https://user-images.githubusercontent.com/75867748/111856334-524ab380-896d-11eb-8f54-94365cfd8e23.png)

- 제일 큰 값을 찾아서 제일 끝에 있는 원소와 자리를 바꾼다.
- 그 다음으로 큰 값을 찾아서 다음으로 맨끝에 있는 원소와 자리를 바꾼다
- 반복해서 최종적으로 오름차순 배치를 한다.

<br>

![02](https://user-images.githubusercontent.com/75867748/111856344-68f10a80-896d-11eb-8149-dff316f723d9.png)

- 2번은 n(n-1)/2로 1과 3보다 작업시간이 젤 커서 얘가 시간복잡도가 된다.
- 최악의 경우 최선의 경우, 평균을 구분할 필요가 없다. 모든 데이터에 대해서 비교연산의 횟수가 n(n-1)/2이기 때문이다.

---

#### 버블소트

![04](https://user-images.githubusercontent.com/75867748/111856569-f8e38400-896e-11eb-9542-c323448de2f5.png)

이전의 선택정렬과 비슷하다. 다만, 최댓값을 찾아 맨 마지막으로 가져오는 세부적인 방법에 있어서 차이가 있다.

첫번째 값을 두 번째 값과 비교하여 첫번째가 더 크면 자리를 바꾼다. 그리고 두번째와 세번째를 비교해서 두번째가 더 크면 자리를 바꾼다. 이런식으로 하면 최대값이 제일 뒤로 오게 되면서 첫번째 phase가 끝난다. 맨 마지막 자리에 온 것을 잊어버린 다음, 다시 똑같은 일을 반복한다.

<br>

![05](https://user-images.githubusercontent.com/75867748/111856606-406a1000-896f-11eb-882e-ad1a8f45aa1e.png)

- last를 찾으면 잊어버리므로 for문을 돌면서 last는 점점 하나씩 줄어든다.
- 1 ~ last-1 까지 탐색을 한 다음 a[i]와 a[i+1]을 비교한 다음, 앞쪽이 더 크면 자리를 교환한다.

---

#### 삽입정렬

![06](https://user-images.githubusercontent.com/75867748/111856943-90e26d00-8971-11eb-9435-1ae92c43d5b8.png)

오름차순을 위해 알맞은 자리에 데이터를 끼워넣는 방식이다. 우선 비교하고자 하는 데이터를 tmp에 복사를 해놓는다. 그리고

1. 앞에서부터 비교해서 tmp보다 큰 숫자가 나올 때까지
2. 뒤에서부터 비교해서 tmp보다 작은 숫자가 나올 때까지

차례대로 비교를 한 다음, 자리를 찾으면 다른 데이터들을 옮긴 뒤 끼워넣는다.

4를 tmp에 복사해놓는다. 그리고 4와 비교하면서 4보다 큰 것들은 한칸 뒤로 shift한다. 4보다 작은 수가 나오면 shift가 멈추면서 빈칸에 4가 들어간다.

<br>

![08](https://user-images.githubusercontent.com/75867748/111857024-1d8d2b00-8972-11eb-8a61-31f106333348.png)

- i가 왜 2부터 시작하냐면, 나와 내 앞의 값을 비교하기 때문이다.
- a[1...i-1]까지는 정렬이 이미 되어있고, 거기에 i를 적당한 자리에 삽입하면 된다.
- 선택정렬이나 버블소트와 차이가 있다. 삽입정렬은 최선일 땐 1, 최악일 때 n^2이다.
