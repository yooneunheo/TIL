## 2- 04. Recursion의 응용: 미로찾기

<br>

![63](https://user-images.githubusercontent.com/75867748/111033201-59e0f880-8453-11eb-9650-7fbf0110ca2b.png)

<br>

![64](https://user-images.githubusercontent.com/75867748/111033277-c1974380-8453-11eb-9fda-a466693a3c31.png)

- 현재 위치 (x,y)가 출구일 때
- 현재 위치가 출구가 아닐 때
  - (x,y)에 인접한 각각의 이웃(x', y')들에 대해서 for문을 돌리는데
    - 만약 이웃이 통로일 때 (벽이면 무시)
      - findPath() : 출구가 있는지 검사
  - for문을 도는 동안 리턴되지 않았다면 아니라면, 네 이웃들 모두 벽이거나 막힌 길이므로 false

<br>

단, 무한루프에 빠지지 않을까를 주의해야한다. 이 코드의 경우 빠질 수 있다. 왜냐하면 (x', y')의 입장에선 (x,y)가 자신의 인접한 cell이다. 따라서 findPath(x',y')를 하면 또 (x,y)에 대해서도 findPath하기 때문에 무한히 왔다갔다하는 일이 발생할 수 있다. 따라서 이를 방지해야 한다.

방지는 어떻게 할까? 어차피 (x,y)에서 (x',y')로 갔다면, 왔던 길인 (x,y)를 다시 지나가지 않도록 하면 된다. 즉, 이미 방문한 곳과 아닌 곳을 분류해서 표시를 한다. 그러면 cell의 갯수가 유한하므로 무한루프에 빠지지 않는다.

<br>

---

<br>

![65](https://user-images.githubusercontent.com/75867748/111033545-22734b80-8455-11eb-9dda-c56159fbd938.png)

- 현재 위치(x,y)가 출구일 때
- 출구가 아니라면
  - (x,y)를 방문한 곳이라고 표시
  - 인접한 이웃들(x',y')에 대해 for문을 돌리는데
    - (x',y')가 통로 && 방문하지 않은 곳일때
      - (x',y')를 검사
  - for문을 도는 동안 리턴되지 않았다면 아니라면, 네 이웃들 모두 벽이거나 막힌 길이므로 false

<br>

이처럼 인접한 셀이 벽이 아닌지 그리고 방문하지 않은 곳인지를 먼저 체크한 후에 recursion으로 들어가는 경우도 있고

<br>

---

<br>

![66](https://user-images.githubusercontent.com/75867748/111033723-fdcba380-8455-11eb-81ec-9bcf90520e7a.png)

혹은 체크하지 않고 바로 recursion을 호출한 다음, recursion의 맨 위로 돌아가서 현재 위치가 벽인지 방문하지 않은 곳인지를 체크하는 방법도 있다. 이런 방식이면 recursion이 호출되는 횟수는 조금 더 늘어나지만 대신 코드는 더 간결해지는 장점이 있다.

<br>

- 현재 위치(x,y)가 벽이거나 방문한 곳일 때
- 현재 위치가 출구일 때
- 그 외
  - (x,y)를 방문한 곳이라고 표시
  - 인접한 이웃들(x',y')에 대해 for문을 돌리는데
    - (x',y')를 검사
  - for문을 도는 동안 리턴되지 않았다면 아니라면, 네 이웃들 모두 벽이거나 막힌 길이므로 false

<br>

---

<br>

이제 코드로 구현하겠다.

![70](https://user-images.githubusercontent.com/75867748/111034323-6d429280-8458-11eb-8efc-d640e4a42aa8.png)

<br>

![71](https://user-images.githubusercontent.com/75867748/111034367-93683280-8458-11eb-86bd-80d4a362d33f.png)

<br>

![72](https://user-images.githubusercontent.com/75867748/111034382-b1359780-8458-11eb-9bfc-0170c458756c.png)

- 우선 좌표값이 유효한지부터 봐야한다. 좌표값은 0 ~ N-1 사이에 있어야 하므로, 음수거나 N보다 같거나 큰 경우면 종료

- x,y가 벽이거나 방문한 곳이라면, 즉 maze[x][y]가 PATHWAY_COLOR가 아닌 경우면 종료

- x, y가 출구일 때, 즉 n-1 인 경우,

  - 녹색으로 색칠하고 종료

- 일반적인 경우
  - 일단 x,y는 방문한 곳이니 칠한다
  - 만약 이웃한 곳 중 하나가 true면 true를 반환하고 종료
  - if문을 통과했다면 출구가 없으므로 꽝
